var routes = {
    '/': ['pages', 'home'],
    '/developers': ['pages', 'developers'],
    '/account': ['accounts', 'edit'],
    '/messages/view/([0-9]+)': ['messages', 'view'],
    // easy way to do a catch-all
    '.*': ['pages', 'not_found']
}
var notifications = {

    // base window title
    base_window_title: 'Team Future!',

    // holds the DOM object that turtl does all of its operations within
    main_container_selector: '#main',

    last_url: '',

    // tells the pages controller whether or not to scroll to the top of the
    // window after a page load
    scroll_to_top: true,

    router: null,

    // a place to reference composer controllers by name
    controllers: {},

    // will hold the user's account
    account: false,

    initialized: false,

    _tmp: {},

    set_title: function(title)
    {
        var escape_regexp_chars = function(str) {
            return (str+'').replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
        };
        var regex   =   new RegExp('(\\s*\\|\\s*'+escape_regexp_chars(notifications.base_window_title)+')*(\\s*\\|)?$', 'g');
        title       =   title.replace(regex, '');
        if(title == '') title = this.base_window_title;
        else title = title + ' | ' + this.base_window_title;
        document.title  =   title;
    },

    init: function() 
    {
        this.account = new Account();

        this.load_controller('pages', PagesController);
        this.load_controller('nav_bar', AccountsNavBarController);

        var router = new Composer.Router(routes);
        router.bind_links({
            exclude_class: 'external'
        });
        router.bind('fail', function(err) {
            console.log('route: fail: ', err);
        });
        this.router = router;

        addon_io.call('are_you_there', {}, function(response) {
            console.log('addon is present: ', response);
        });

        if (this._tmp.addon_exists)
            this.activate_addon();

        this.initialized = true;
    },

    load_controller: function(name, controller, params, options)
    {
        options || (options = {});

        if(this.controllers[name]) return this.controllers[name];

        // lol this is my comment.
        this.controllers[name]  =   new controller(params, options);
        return this.controllers[name];
    },

    render_template: function(template, data)
    {
        console.log('template: ', template)
        return _.template($('#'+template).html(), data);
    },

    set_addon_data: function(data)
    {
        this._tmp.addon_exists = true;
        this._tmp.addon_data = data;
    },

    activate_addon: function()
    {
        console.log('Activating add-on functionality!');

        this.account.activate_addon(this._tmp.addon_data);

        delete this._tmp.addon_exists;
        delete this._tmp.addon_data;
    },

    route: function(url, options)
    {
        this.router.route(url, options);
    },
}
document.addEventListener('notifications_add_on_message', function(e) {  
    console.log('app received message from content script: ', e);
    switch (e.detail.msg_type) {
        case 'activate':
            notifications.set_addon_data(e.detail.data);

            if (notifications.initialized)
                notifications.activate_addon();

            break;

        case 'put_access_token':

            if (!notifications.account)
                return false;
            
            notifications.account.set_access_token(e.detail.data.access_token);

            break;

        case 'open_settings':
            
            notifications.route('/account');

            break;
    }
});
$(function() {
    notifications.init();
    $(".dropdown-toggle").dropdown();
});
var AccountsEditController = Composer.Controller.extend({
    inject: notifications.main_container_selector,
    el: false,
    className: 'accounts',

    elements: {
        
    },

    events: {

    },

    _tmp_data: false,

    
    init: function(data)
    {
        this.with_bind(notifications.account, 'change:addon_data', this.render.bind(this));
        this.render();
        
        return this;
    },


    render: function()
    {
        data = {}



        console.log('addon_data: ', notifications.account.get('addon_data'));
        if (!notifications.account.get('addon_data').access_token)
        {
            var html = notifications.render_template('pages_loading', data);
        }
        else
        {
            var html = notifications.render_template('accounts_edit', data);
        }

        
        this.html(html);

        return this;
    },
});


var AccountsNavBarController = Composer.Controller.extend({
    inject: '#nav',
    el: false,
    template: 'accounts_nav_bar',

    elements: {
        
    },

    events: {

    },

    _tmp_data: false,

    
    init: function(data)
    {
        console.log('data: ', this.id);

        this.with_bind(notifications.account, 'change:addon_exists', this.render.bind(this));

        this.render();
        
        return this;
    },


    render: function()
    {
        console.log('RENDERING NAV BAR');

        data = {
            id: this.id
        }

        var html = notifications.render_template(this.template, data);
        this.html(html);

        if (notifications.account.get('addon_exists') == false)
            this.track_subcontroller('right_nav', function() {
                return new DownloadButtonController({
                    style: 'nav',
                    inject: '#nav_right'
                });
            });
        else
            this.track_subcontroller('right_nav', function() {
                return new AccountsNavBarDropdownController();
            });


        return this;
    },
});


var AccountsNavBarDropdownController = Composer.Controller.extend({
    inject: '#nav_right',
    tag: 'li',
    el: false,
    template: 'accounts_nav_bar_dropdown',

    elements: {
        
    },

    events: {
        'click a': 'handle_dropdown'
    },

    _tmp_data: false,

    
    init: function(data)
    {
        this.render();
        
        return this;
    },


    render: function()
    {
        var html = notifications.render_template(this.template, data);
        this.html(html);

        return this;
    },

    handle_dropdown: function(e) {
        /*
        e.preventDefault();
        return false;
        */
    }
});


var DownloadButtonController = Composer.Controller.extend({
    inject: null,   // overridden
    style: null,    // 'nav' | 'big'
    el: false,
    tag: 'li', 

    elements: {
        
    },

    events: {
        'click a': 'do_install'
    },

    _tmp_data: false,

    
    init: function(data)
    {
        this.render();
        
        return this;
    },


    render: function()
    { 
        console.log('RENDERING NAV BAR');

        data = {
            browser: this.get_browser()
        }

        switch(this.style) {
            case 'nav':

                if (data.browser == 'Other')
                    return console.log('Other browser not supported here :(');

                var template = 'download_button_nav'
                break;
            case 'big':

                var template = 'download_button_big'
                break;
        }

        var html = notifications.render_template(template, data);
        this.html(html);

        return this;
    },

    do_install: function(e) {

        e.preventDefault();

        switch (this.get_browser()) {
            case 'Chrome':
                console.log('Trying to install from webstore')
                chrome.webstore.install();

                break;

            case 'Firefox':

                var params = {
                    "Team Future for Firefox": {
                        URL: '/downloads/xpi/team_future.0.0.1.xpi',  
                        IconURL: '/images/download/teamfuture_32x32.png',
                        
                        toString: function () { return this.URL; }
                    }
                };
                InstallTrigger.install(params);

                break;

            default:
                alert('your browser is not supported lol');
                break;
        }


        return false;
    },

    get_browser: function() {
        if (window.chrome)
            return 'Chrome';
        else if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1)
            return 'Firefox';
        else
            return 'Other';
    }
});


var MessagesViewController = Composer.Controller.extend({
    inject: notifications.main_container_selector,
    el: false,
    template: 'messages_view',

    elements: {
        
    },

    events: {

    },

    _tmp_data: false,

    
    init: function(data)
    {
        console.log('data: ', this.id);
        this.render();
        
        return this;
    },


    render: function()
    {
        data = {
            id: this.id
        }

        var html = notifications.render_template(this.template, data);
        this.html(html);

        return this;
    },
});


var PagesLandingController = Composer.Controller.extend({
    inject: notifications.main_container_selector,
    el: false,
    template: 'pages_home',
    className: 'pages',

    elements: {
        
    },

    events: {

    },

    _tmp_data: false,

    
    init: function(data)
    {
        this.with_bind(notifications.account, 'change:addon_exists', this.render.bind(this)); 
        this.render();
        
        return this;
    },


    render: function()
    {
        data = {
            id: this.id
        }

        var html = notifications.render_template(this.template, data);
        this.html(html);

        if (notifications.account.get('addon_exists') == false)
            this.track_subcontroller('download_button', function() {
                return new DownloadButtonController({
                    style: 'big',
                    inject: '.download'
                });
            });

        return this;
    },
});


var PagesController =   Composer.Controller.extend({
    inject: notifications.main_container_selector,
    className: 'pages',

    template: 'pages_home',

    cur_controller: false, 

    init: function()
    {
        this.bind('onroute', this.on_route.bind(this));
        this.bind('preroute', this.pre_route.bind(this));
        this.bind('route', this.pre_load.bind(this));
        this.bind('loaded', this.post_load.bind(this));
    },

    release: function()
    {
        this.release_current();
        this.unbind();
        return this.parent();
    },

    on_route: function(url)
    {
    },

    pre_route: function(url)
    {
        // scroll to the top of the window (but ONLY if we're not in a modal).
        var last    =   (notifications.last_url || window.location.pathname).replace(/\-\-.*/, '');
        var cur     =   url.replace(/\-\-.*/, '');
        if(last != cur)
        {
            // this variable is read by the pages controller on post_load to see
            // if we should scroll to the top after a trigger('loaded') event.
            // if we did the scroll here, it would happen before the page content
            // changes and would be confusing.
            notifications.scroll_to_top =   true;
        }
    },

    pre_load: function()
    {
        this.page_loading(true);
    },

    post_load: function()
    {
        // unhide body after initial HTML has loaded
        $(document.body).removeClass('initial');

        // this is delayed to prevent a race condition where the "route" event
        // fires after the "loaded" event
        setTimeout(function() { this.page_loading(false); }.bind(this), 200);

        // scroll_to_top is set in the notifications::route_callback function in notifications.js
        //console.log('scroll');
        if(notifications.scroll_to_top)
        {
            window.scrollTo(0, 0);
            notifications.scroll_to_top =   false;
        }

    },

    load: function(cls, data, options)
    {
        data || (data = {});
        options || (options = {});

        if(typeof(cls) == 'string')
        {
            var cls =   window[cls];
        }

        // load the controller, setting is as the current controller for the page.
        // this helps us track and release it later on
        if(options.keep_current && cls == this.cur_controller.$constructor)
        {
            Object.each(data, function(v, k) {
                this.cur_controller[k]  =   v;
            }, this);
            this.cur_controller.init();
        }
        else
        {
            this.release_current();
            this.cur_controller =   new cls(data, {clean_injection: true});
        }

        if(!options.skip_loaded_event)
        {
            // trigger the loaded event unless asked not to (presumably by the
            // handler). also, delay the event just to catch any last-minute
            // async issues.
            setTimeout(function() {
                this.trigger('loaded');
            }.bind(this), 1);
        }

        // return the controller
        return this.cur_controller;
    },

    load_static: function(tpl, data)
    {
        data || (data = {});

        this.release_current();

        this.template   =   tpl;
        this.render(data);

        // technically does the same thing, and faster.
        $(notifications.main_container_selector).append(this.el);

        this.trigger('loaded');
    },

    render: function(data)
    {
        data || (data = {});

        var html = notifications.render_template(this.template, data);
        this.html(html);

        return this;
    },

    /**
     * if there is a controller currently being displayed through the pages system,
     * release it and nullify the reference to it.
     */
    release_current: function()
    {
        // clear title so it doesn't persist across pages when the target page
        // doesn't set it
        notifications.set_title('');

        if(!this.cur_controller) return false;
        this.cur_controller.release();
        this.cur_controller =   false;
        return true;
    },

    page_loading: function(yesno)
    {
        var yesno   =   !!yesno;
        if(yesno)
        {
            $(document.html).addClass('loading');
        }
        else
        {
            $(document.html).removeClass('loading');
        }
    }
});
var accounts = {
    edit: function()
    {
        notifications.controllers.pages.load(AccountsEditController, {});
    }

}
var messages = {
    view: function(id) {
        notifications.controllers.pages.load(MessagesViewController, {id: id});
    }
}
var pages = {
    home: function()
    {
        notifications.controllers.pages.load(PagesLandingController, {});
    },

    developers: function()
    {
        notifications.controllers.pages.load_static('pages_developers', {});
    },

    welcome: function()
    {
        notifications.controllers.pages.load_static('pages_welcome', {});
    }
}
var Account  =   Composer.Model.extend({
    defaults: {
        name: 'Valued Customer',
        addon_exists: false,
        addon_data: {}
    },

    init: function(options) {
    },

    activate_addon: function(data) {
        console.log('activating add-on in account model! ', data.settings);
        this.set(
            {
                addon_exists: true,
                addon_data: data.settings
            }
        );
        if (!data.access_token)
            this.get_access_token();
    },

    get_access_token: function() {
        console.log('Getting access token...');

        // the add-on will send this back down via a direct message
        addon_io.call('get_access_token', {});
    },

    set_access_token: function(token) {
        this.set_addon_data_val('access_token', token);

        console.log('Saved access token in account model: ', token, this.get('addon_data'));
    },

    set_addon_data_val: function(prop, val) {

        var addon_data = this.get('addon_data');
        addon_data[prop] = val;
        this.set({ addon_data: addon_data });
        this.trigger('change:addon_data');
        
        return this;
    }

});